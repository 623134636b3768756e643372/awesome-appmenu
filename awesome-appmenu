#!/usr/bin/env python

#  awesome-appmenu is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

#  sbomgr is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with sbomgr.  If not, see <http://www.gnu.org/licenses/>.

#  Copyright (C) 2016 Daniel Prosser

import os, sys
from copy import copy

# Try to import configuration file
try:
  sys.path.insert(0, os.environ["HOME"] + "/.config/awesome-appmenu")
  import menurc
  config = True
except:
  config = False

################################################################################
# Launcher: finds and stores information for a .desktop file
class Launcher():

  def __init__(self, launcherfile, use_icon=True, 
               icon_search_paths=["/usr/share/icons/hicolor"]):
    self.Name = None
    self.Exec = None
    self.IconGenericName = None
    self.Icon = None
    self.NoDisplay = False
    self.OnlyShowIn = None
    self.Categories = []
   
    self.getInfo(launcherfile, use_icon)
    if (use_icon and self.IconGenericName and not self.NoDisplay): 
      self.findIcon(icon_search_paths)

  # Reads info from launcher file
  def getInfo(self, launcherfile, use_icon):

    f = open(launcherfile)
    for line in f:
      splitline = line.split("=")

      if splitline[0] == "Name":
        # If Name is being defined again, just go on (google chrome and 
        # Libreoffice do this)
        if self.Name: break
        else: self.Name = splitline[1].strip()

      elif splitline[0] == "Exec":
        # Sometimes Exec lines have '=' if they set environment variables
        self.Exec = ""
        for i in range(1, len(splitline)):
          self.Exec += splitline[i].strip()

      elif splitline[0] == "Icon":
        if use_icon:
          if ( (splitline[1].strip()[-4:] == ".png") or 
               (splitline[1].strip()[-4:] == ".svg") or
               (splitline[1].strip()[-4:] == ".jpg") ):
            self.Icon = splitline[1].strip()
          else:
            self.IconGenericName = splitline[1].strip()

      elif splitline[0] == "Categories":
        self.Categories = splitline[1].split(";")
        for i in range(len(self.Categories)):
          self.Categories[i] = self.Categories[i].strip()

      elif splitline[0] == "NoDisplay":
        if (splitline[1].strip() == "true"): self.NoDisplay = True

  # Finds icon by generic name
  def findIcon(self, icon_search_paths):

    # Note: this just takes the first matching icon that is encountered. It
    # doesn't prefer any particular size if there are multiple matches.
    for directory in icon_search_paths:

      # Skip any directory that doesn't exist
      if not os.path.isdir(directory): continue

      # Descend into directory
      for root, dirs, files in os.walk(directory):
        for name in files:
          if name[:-4] == self.IconGenericName:
            self.Icon = os.path.join(root, name)
            break
        if self.Icon: break
      if self.Icon: break

################################################################################
# Category: groups and sorts launchers
class Category():

  def __init__(self, listed_name, name, use_icon=True, icon_generic_name=None,
               icon_search_paths=["/usr/share/icons/hicolor"]):
    self.ListedName = listed_name
    self.Name = name
    self.UseIcon = use_icon
    self.IconGenericName = icon_generic_name
    self.Icon = None
    self.NumLaunchers = 0
    self.Launchers = []

    # Determine if icon_generic_name supplied is actually an icon
    if use_icon and icon_generic_name:
      if ( (icon_generic_name.strip()[-4:] == ".png") or 
           (icon_generic_name.strip()[-4:] == ".svg") or
           (icon_generic_name.strip()[-4:] == ".jpg") ):
        self.Icon = icon_generic_name
        self.IconGenericName = None

    if (use_icon and self.IconGenericName): self.findIcon(icon_search_paths)

  # Finds icon by generic name
  def findIcon(self, icon_search_paths):

    # Note: this just takes the first matching icon that is encountered. It
    # doesn't prefer any particular size if there are multiple matches.
    for directory in icon_search_paths:

      # Skip any directory that doesn't exist
      if not os.path.isdir(directory): continue

      # Descend into directory
      for root, dirs, files in os.walk(directory):
        for name in files:
          if name[:-4] == self.IconGenericName:
            self.Icon = os.path.join(root, name)
            break
        if self.Icon: break
      if self.Icon: break

  # Adds a launcher
  def addLauncher(self, launcher):
    self.Launchers.append(launcher)
    self.NumLaunchers += 1

  # Sorts launchers
  def sortLaunchers(self):

    # Create a list of launchers by name
    launchernames = []
    for launcher in self.Launchers:
      launchernames.append(launcher.Name)

    # Sort the list and create a new self.Launchers list
    launchernames.sort()
    templaunchers = copy(self.Launchers)
    self.Launchers = []
    for name in launchernames:
      for launcher in templaunchers:
        if launcher.Name == name: 
          self.Launchers.append(launcher)
          break

################################################################################
# Menu: groups categories
class Menu():

  def __init__(self):
    self.Categories = []
    self.NumCategories = 0

  # Adds a category
  def addCategory(self, category):
    self.Categories.append(category)
    self.NumCategories += 1

  # Finds launchers and adds them to appropriate categories
  def getLaunchers(self, launcherpaths, use_icon=True, icon_search_paths=
                   ["/usr/share/icons/hicolor"]):

    # See if there's a Miscellaneous category or create it if needed
    miscidx = -1
    for i in range(self.NumCategories):
      if self.Categories[i].Name == "Miscellaneous":
        miscidx = i
        break
    if miscidx == -1:
      self.addCategory(Category("Miscellaneous", "Miscellaneous", use_icon,
                                "applications-other", icon_search_paths))
      miscidx = self.NumCategories - 1

    # Find and group launchers into categories
    for directory in launcherpaths:
      for root, dirs, files in os.walk(directory):
        for name in files:
          if name[-8:] == ".desktop":
            newlauncher = Launcher(os.path.join(root, name), use_icon,
                                   icon_search_paths)
            
            # Only register the launcher if it has an Exec= field and if it
            # does not have NoDisplay=true
            if (newlauncher.Exec and not newlauncher.NoDisplay):
              self.assignLauncher(newlauncher)

  # Adds launcher to appropriate category(ies)
  def assignLauncher(self, launcher):

    launcher_grouped = False
    for category_name in launcher.Categories:
      for category in self.Categories:
        if category_name == category.ListedName:
          category.addLauncher(launcher)
          launcher_grouped = True

    # Put it in Miscellaneous category if nothing else fits
    if not launcher_grouped:
      self.Categories[self.NumCategories-1].addLauncher(launcher)

  # Sorts launchers in each category
  def sortLaunchers(self):

    for category in self.Categories: category.sortLaunchers()

  # Writes menu for awesomeWM
  def write(self):

    home = os.environ["HOME"]
    menufile = home + "/.config/awesome/appmenu.lua"
    try:
      f = open(menufile, 'w')
    except IOError:
      os.makedirs(home + "/.config/awesome")
      f = open(menufile, 'w')

    # Header
    f.write("local appmenu = {}\n\n")

    # Write categories as long as they are not empty
    for category in self.Categories:
      if category.NumLaunchers == 0: continue
      f.write("appmenu." + category.Name + " = {\n")
      for launcher in category.Launchers:
        f.write("    { '" + launcher.Name + "', '" + launcher.Exec + "'")
        if launcher.Icon: 
          f.write(", '" + launcher.Icon + "'")
        f.write(" },\n")
      f.write("}\n\n")

    # Write menu
    f.write("appmenu.Appmenu = {\n")
    for category in self.Categories:
      if category.NumLaunchers == 0: continue
      f.write("    { '" + category.Name + "', appmenu." + category.Name)
      if category.Icon:
        f.write(", '" + category.Icon + "'")
      f.write(" },\n")
    f.write("}\n\n")

    f.write("return appmenu")

    # Close file and print notification
    f.close()
    print("Wrote " + menufile + ".")

################################################################################
# Reads configuration file
def load_config():
  global config

  # Set defaults
  home = os.environ["HOME"]
  launcherpaths = ["/usr/share/applications", 
                   home + "/.local/share/applications"]
  iconpaths = ["/usr/share/icons/hicolor"]
  categories = [ ["Utility",   "Accessories", "applications-utilities"],
               ["Development", "Development", "applications-development"],
               ["Education",   "Education",   "applications-science"],
               ["Game",        "Games",       "applications-games"],
               ["Graphics",    "Graphics",    "applications-graphics"],
               ["Network",     "Internet",    "applications-internet"],
               ["Office",      "Office",      "applications-office"],
               ["AudioVideo",  "MultiMedia",  "applications-multimedia"],
               ["Settings",    "Settings",    "applications-accessories"],
               ["System",      "System",      "applications-system"],
               ["Wine",        "Wine",        "wine"] ]

  # Read configuration
  if config:

    try: launcherpaths = menurc.launcherpaths
    except AttributeError:
      print("Warning: menurc.py does not have launcherpaths. Using default.")

    try: iconpaths = menurc.iconpaths
    except AttributeError:
      print("Warning: menurc.py does not have iconpaths. Using default.")

    try: categories = menurc.categories
    except AttributeError:
      print("Warning: menurc.py does not have categories. Using default.")

  return launcherpaths, iconpaths, categories

################################################################################
# Prints usage info
def print_help():

  print("Usage: " + sys.argv[0] + " OPTION")
  print("Options:")
  print("  --no-icons, -n: generate a menu without icons")
  print("  --help, -h: show this help screen")

################################################################################
# Main program: generates an application menu for Awesome
if __name__ == "__main__":

  # Get command line arguments
  use_icon = True
  if len(sys.argv) == 2:
    if (sys.argv[1] == "--no-icons") or (sys.argv[1] == "-n"):
      use_icon = False
    elif (sys.argv[1] == "--help") or (sys.argv[1] == "-h"):
      print_help()
      exit(0)
    else:
      print_help()
      exit(1)
  elif len(sys.argv) > 2:
    print_help()
    exit(1)

  # Load configuration file
  launcherpaths, iconpaths, categories = load_config()

  # Create a list of categories
  if use_icon: print("Finding category icons ...")
  appmenu = Menu()
  ncategories = len(categories)
  for i in range(ncategories):
    appmenu.addCategory(Category(categories[i][0], categories[i][1], use_icon,
                                 categories[i][2], iconpaths))

  # Find launchers and add them to appropriate categories
  if use_icon: print("Finding launcher files and icons ...")
  else:        print("Finding launchers ...")
  appmenu.getLaunchers(launcherpaths, use_icon, iconpaths)

  # Sort launchers
  print("Sorting launchers ...")
  appmenu.sortLaunchers()

  # Write menu for awesomeWM
  appmenu.write()
